(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{515:function(n,i,e){"use strict";e.r(i);var l=e(29),t=Object(l.a)({},(function(){var n=this,i=n.$createElement,e=n._self._c||i;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("##1. JDK和JRE的区别\nJRE Java 运行时环境，指的是Java程序运行是需要的环境，面对用户端 Java Runtime  Jre 包含JVM。\nJDK Java 开发时环境，面对的Java程序的开发人员。jdk包含JRE，和Java工具和基础类库\n##2. == 和 equals 的区别是什么？\n== 是比较运算符，如果比较的两个操作数都是数值类型的话，比较的是他们的值，如果是引用类型的话比较的他们在内存的地址"),e("br"),n._v('\nequals是object的方法，底层同样是使用的==运算符，但是有些继承类对该方法进行了重写，比如String\n##3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？\n不一定，HashCode返回的是哈希码值，equals比较的是两个对象是否相等，如果equals相等的话，hashCode一定是相等的，反之则不一定。 因为在重写equals()方法的时候上面有标注，必需同时重写hashCode方法，来保证hashCode的常规协定。比如hashSet中比较是否重复，会依次比较hashCode和equals方法，如果你只重写了equals，那么hashCode继承了Object的是取得内存编码，出现hashCode不同\n##4. final 在 java 中有什么作用？\nfinal 作用java的关键字可以用在三个地方，用来修饰类，方法，变量。\n修饰类，被修饰的类不能被继承，\n修饰方法，被修饰的方法不能被重写\n修饰变量，被修饰的变量只能一次赋值，不能改变。如果是引用类型的话，引用在初始化后永远指向一个地址不可修改，但是改地址保存的对象信息是可以被修改的\n##5. java 中的 Math.round(-1.5) 等于多少？\n-1   四舍五入 是 -1.5 + 0.5 = -1.0 并向下取整 等于-1\n##6. String 属于基础的数据类型吗？\n不属于\n基本数据类型有 整型:byte short int long  浮点型:float double 字符型：char boolean\n##7. java 中操作字符串都有哪些类？它们之间有什么区别？\n这三个都是使用char[]数组的形式来保存字符，不同的是\nString 该类型不可变，对字符床的操作等于新创建了一个对象\nString builder 的操作都是对对象进行操作，不会新建对象，线程需安全，性能忧\nString buffer  的操作都是对对象进行操作，不会新建对象，每个方法都加了synchronized修饰，所以是线程安全的，但是性能肯定不如builder\n##8. String str="i"与 String str=new String(“i”)一样吗？\n不一样，第一个属于赋值操作 相当于把“i” 的内存地址给到str  String是final修饰的  所以i应该在常量池\n第二个数据新建对象在赋值，不是同一个对象，new Stirng 对象 这个i在堆内存中\n##9. 如何将字符串反转？\n将字符转换成StringBuilder 然后死用reverse方法反转\n##10. String 类的常用方法都有那些？')]),n._v(" "),e("ul",[e("li",[n._v("subString 截取")]),n._v(" "),e("li",[n._v("indexOf 获取指定位置字符")]),n._v(" "),e("li",[n._v("laseIndexOf 从后获取")]),n._v(" "),e("li",[n._v("TolowerCase 变小写")]),n._v(" "),e("li",[n._v("ToUpperCase 变大写")]),n._v(" "),e("li",[n._v("trim   去空格")]),n._v(" "),e("li",[n._v("replase 替换")]),n._v(" "),e("li",[n._v("split  切割")]),n._v(" "),e("li",[n._v("length 长度")]),n._v(" "),e("li",[n._v("equals 比较\n##11. 抽象类必须要有抽象方法吗？\n不是  抽象方法的类必需是抽象类\n##12. 普通类和抽象类有哪些区别？")]),n._v(" "),e("li",[n._v("抽象类 使用abstract修饰的，")]),n._v(" "),e("li",[n._v("抽象方法不能有方法主体，")]),n._v(" "),e("li",[n._v("子类必需实现方法，除非是抽象类")]),n._v(" "),e("li",[n._v("不能实例化")]),n._v(" "),e("li",[n._v("不能用private final static 来修饰\n##13. 抽象类能使用 final 修饰吗？\n##14. 接口和抽象类有什么区别？")]),n._v(" "),e("li",[n._v("抽象类可以有构造方法  接口不可以")]),n._v(" "),e("li",[n._v("抽象类可以有普通成员变量  接口只有静态常量")]),n._v(" "),e("li",[n._v("抽象类可以有方法的实现，可以有静态方法  接口只有方法的声明")]),n._v(" "),e("li",[n._v("类只能继承一个抽象类，可以实现多个接口\n##15. java 中 IO 流分为几种？\n按照流向分的话 分为输入流和输出流\n按照操作单元划分的话分为，字节流和字符流。他们由四个抽象类来标识，inputStream,outputStrema,Writer,Reader\n##16. BIO、NIO、AIO 有什么区别？")]),n._v(" "),e("li",[n._v("BIO 同步阻塞IO 一个连接一个线程 开销较大 适合连接比较少的")]),n._v(" "),e("li",[n._v("NIO同步非阻塞一个请求一个线程，所有的请求都会转发到多路复用器上，轮训到有io请求是才启动一个线程 适合连接比较多的 轻连接")]),n._v(" "),e("li",[n._v("AIO异步非阻塞一个有效请求一个线程。请求都是由OS先完成之后，在通知服务器应用来启动线程处理，适合连接多的  重连接\n##17. Files的常用方法都有哪些？")]),n._v(" "),e("li",[n._v("Files.exists() 文件是否存在")]),n._v(" "),e("li",[n._v("Files.createFile() 创建文件")]),n._v(" "),e("li",[n._v("Files.createDirectory()  创建文件夹")]),n._v(" "),e("li",[n._v("Files.move() 移动")]),n._v(" "),e("li",[n._v("Files.copy() 复制")]),n._v(" "),e("li",[n._v("Files.size() 查看文件个数")]),n._v(" "),e("li",[n._v("Files.write() 写")]),n._v(" "),e("li",[n._v("Files.read() 读\n##18. java 容器都有哪些？\nStirng,数组，java.util下的集合\nString 底层使用char[] 长度是 integer.integer.max_value\n数组 integer.max_value\nMap 键值对集合\nset 无序集合\nlist 有序集合\n##19. Collection 和 Collections 有什么区别？")]),n._v(" "),e("li",[n._v("Collection 集合接口，为各种具体的集合提供统一的操作方式，实现该接口的类有list set")]),n._v(" "),e("li",[n._v("Collections 是一个工具类，提供了对各种集合的操作，搜索，排序，线程安全化\n##20. List、Set、Map 之间的区别是什么？")])]),n._v(" "),e("blockquote",[e("p",[n._v("List 有序集合 可重复")]),n._v(" "),e("blockquote",[e("ul",[e("li",[n._v("ArrayList  长度可变的数组，可以对元素随机访问，查询速度快，操作速度慢")]),n._v(" "),e("li",[n._v("linkedList 链表结构的集合，插入和删除速度快， 但是查询速度慢")])])])]),n._v(" "),e("blockquote",[e("p",[n._v("set 无序集合 不可重复")]),n._v(" "),e("blockquote",[e("ul",[e("li",[n._v("HashSet 按照哈希算法来存取集合中的对象，存取速度快")]),n._v(" "),e("li",[n._v("TreeSet 实现了SortSet接口，能够对集合中的对象进行排序")])])])]),n._v(" "),e("blockquote",[e("p",[n._v("Map 键值对集合")]),n._v(" "),e("blockquote",[e("ul",[e("li",[n._v("HashMap底层是一个数组，散列表，插入和读取的开销是固定的。数组的每个元素又是一个链表，通过hashCode存入元素，如果该位置有元素，将会以链表的形式存放，新加入的在链头，第一个在链尾")]),n._v(" "),e("li",[n._v("LinkedHahsMap 于hashMap类型，但是遍历的时候会根据插入顺序，或者是最近最少使用的顺序，内部是使用链表维护的")]),n._v(" "),e("li",[n._v("TreeMap 基于红黑树，,获取的键或者键值都是经过排序的。唯一一个带有subMap方法的map，他可以返回一个子树\n##21. HashMap 和 Hashtable 有什么区别？\n继承的父类不同，一个Dictionary 一个是AbstractMap\nHashTable 是线程安全的，他的方法都有Synchronize修饰的,\nHashMap 可以使用 Collections.SynchronizeMap方法来实现线程安全\n##22. 如何决定使用 HashMap 还是 TreeMap？\nHashMap 底层是使用散列HashCode 所有查询比较快\nTreeＭap 默认根据Key升序， 底层使用红黑树，增加创建使用\n##23. 说一下 HashMap 的实现原理？\nHashMap 底层是使用数组加链表实现，每个数组保存链表\n当使用put方式的时候，会调用KEY的HashCode方法，通过哈希运算和其他的运算得到它在数组的具体位置，通过这种方式将不同的Key-Value 散列到数组的不同位置"),e("br"),n._v("\n在存储的时候如果该位置没有元素，则直接存储，如果有的话会用key进行equals比较，如果相同，key不变，直接覆盖值。不同的话继续向下一个节点比较，到最后都没有相同的元素的话就插入到链表的头部。\n取的话跟插入时去比较的方式是一样的\njdk1.8 之后做了一点改变，为了不影响遍历效率，如果一个链表的长度超过8，就转变为红黑二叉树\n##24. 说一下 HashSet 的实现原理？\n同上\n##25. ArrayList 和 LinkedList 的区别是什么？\nArrayList是基于索引的数据结构，适合对元素随机访问，操作速度慢，如果添加或者删除，需要重排数据\nLinkedList 是基于链表，查询速度慢，操作速度快"),e("br"),n._v("\n##26. 如何实现数组和 List 之间的转换？\nList转数组 toArray  数组转List  Arrays.asList()\n##27. ArrayList 和 Vector 的区别是什么？\nArrayList  线程不安全，性能好，扩容 %50\nVector 线程安全，所有方法加了Synchronize, 扩容翻倍\n##28. Array 和 ArrayList 有何区别？")])])])]),n._v(" "),e("ul",[e("li",[n._v("内容 数组可以存基本类型和对象类型，只能是同种类型\nlsit 只能存对象，可以存多种类型")]),n._v(" "),e("li",[n._v("空间 数组固定，list 不固定"),e("br"),n._v("\n##29. 在 Queue 中 poll()和 remove()有什么区别？\n对队列返回和移除头操作 remove在null的情况下会抛异常 poll则不会\nadd offer  add 满的情况抛异常\npeek elemnt  element  查看异常\n##30. 哪些集合类是线程安全的？\nHahstable Vector concurrentHashMap  stack  枚举\n##31. 迭代器 Iterator 是什么？\n迭代器， 迭代器模式，用于顺序访问集合的元素，不需要知道集合的底层实现\n迭代器是可以遍历集合的对象。为各种容器提供了操作接口，所有的collcation体系的集合都有自己的迭代器。\n##32. Iterator 怎么使用？有什么特点？\nhasNext 和next遍历\nremove 删除\nforeachRemaining 遍历\n特点 在遍历的时候不允许线程对集合进行修改。在遍历的时候能删除，依附某个collection对象\n##33. Iterator 和 ListIterator 有什么区别？\nListIterator继承Iterator\n多了一些功能 添加，逆向遍历等。\nlist可以定位当前的索引位置 ，list可以操作元素 只能用于list集合\n##34. 怎么确保一个集合不能被修改？\n使用Collections的unmodifiableList,Collections.unmodifiableSet方法\n##35. 并行和并发有什么区别？")]),n._v(" "),e("li",[n._v("并行：指的是多个事件在同一时刻执行，是在不同实体上的事件")]),n._v(" "),e("li",[n._v("并发：指的是多个事件在同一时间间隔发生，是在一个实体上的事件\n##36. 线程和进程的区别？")]),n._v(" "),e("li",[n._v("进程是具有一定独立功能的应用程序，是系统进行资源分配和调用的独立单位")]),n._v(" "),e("li",[n._v("线程可以说是进程的实体，是cpu调度和分配的最小单位。线程自己基本上不拥有系统资源，只有一些（计数器，寄存器，栈），并可以和其他共属于一个进程的线程共享资源，可以创建和销毁其他线程。\n在串行程序上引入线程是为了提高并发度，从而提高程序的运行效率和响应时间\n##37. 守护线程是什么？")]),n._v(" "),e("li",[n._v("守护线程，服务线程，准确的来说就是用来服务其他线程。比如Java的哪里回收线程。就是守护线程，用户线程执行完了，main都执行玩了，jvm自然也停止了，守护线程也就结束了。\n##38. 创建线程有哪几种方式？")]),n._v(" "),e("li",[n._v("继承Thread类创建线程\n重写Run方法，也就是执行体，初始化然后调用start方法")]),n._v(" "),e("li",[n._v("Runnable实现该接口 重写Run方法，创建Thread传入Runnable调用start")]),n._v(" "),e("li",[n._v("Callable方法Futrue,有返回值的线程\n##39.说一下 runnable 和 callable 有什么区别？\nRunnable的方法是run，callable是call，callable是有返回值的并且可以抛出异常。他的执行结果会返回一个Future类型的结果，通过get获取返回值\n##40. 线程有哪些状态？\n新建状态，new Thread() 新建线程，还没有启动\n就绪状态，调用了start()方法，由于没有分配cpu,等待执行\n执行状态，获取了cpu资源 开始执行任务\n阻塞状态，通过sleep,wait，或者执行耗时的输入和输出时将让出cpu 将线程挂起，如果是sleep，wait方法挂起，线程不会进入线程队列（排队等待资源分配），而是等挂起的原因解除之后才进入队列\n死亡状态：run执行完毕，或者stop. 不推荐stop  使用boolead来停止程序\n##41.sleep() 和 wait() 有什么区别？\nslepp 属于Thread类中的方法，该方法将线程挂起一定时间，让出cpu资源，但是依然保持监控状态。并且不会让出锁\nwait是Object的方法 当调用wait方法，会放弃锁对象，进入线程等待池，只有等到针对此对象的notify()或者notifyAll，才会重新进入就绪队列，等待获得锁进入运行状态\n注意的点：sleep 谁调用，谁睡觉，a调用了b的sleep方法，还是a睡觉，sleep(0)立即出发一次CPU竞争\n##42. notify()和 notifyAll()有什么区别？\n等待池：假如线程A调用了某个对象的wait方法，就会立即释放锁，并进入该对象的等待池。等待池中的对象不会竞争该对象的锁\n锁池： 只有获取的对象的锁才能执行对象的同步代码块中的代码，每次只有一个线程可以获取，其他的就在锁池等待\nnotify随机唤醒一个等待池的对象，进入锁池，all就是唤醒所有进入锁池\n##43. 线程的 run()和 start()有什么区别？\nRun，代表线程处理逻辑的主入口，由虚拟机调用，不是由应用代码调用的。\nstart,是启动线程，使线程进入就绪状态，并没有运行！\n##44.创建线程池有哪几种方式？")]),n._v(" "),e("li",[n._v("newSingleThreadExecutor 单线程池，只有一个线程工作，所有任务串行执行。并且是按照提交顺序执行的")]),n._v(" "),e("li",[n._v("newFixedThreadPool 固定大小的线程池。每次提交一个任务创建一个，直到最大大小保持不变")]),n._v(" "),e("li",[n._v("newChchedThreadPool 创建一个可缓存的线程池，如果线程大小超过了所需的线程会进行回收，60s,当新任务来的时候，智能的增加，大小取决于操作系统的最大限制")]),n._v(" "),e("li",[n._v("newscheduledThreadPook 定长的线程池 支持定时，周期执行任务。\n##45. 线程池都有哪些状态")]),n._v(" "),e("li",[n._v("RUNNING:最正常的状态，接受任务，处理队列中的任务， 初始化之后就是这个状态")]),n._v(" "),e("li",[n._v("SHUTDOWN: 不接受新的任务，但是会处理队列中的任务，shutdown方法")]),n._v(" "),e("li",[n._v("STOP : 不接受任务，不处理等待队列中的任务，中断当前在执行任务的线程，shutdownNow()")]),n._v(" "),e("li",[n._v("TIDYING: 所有的任务都销毁了，workCound 为0，在转为该状态前为执行钩子函数terminated(),用于可以自定义相应的处理，在shutdown状态，阻塞队列和线程池执行的任务也为空就编程TIDYING状态，在stop状态，执行的任务为空就变味TIDYING")]),n._v(" "),e("li",[n._v("TERMINATED 执行完terminated方法之后就为该状态\n##46. 线程池中 submit()和 execute()方法有什么区别？")]),n._v(" "),e("li",[n._v("submit：参数Runnable和Callable 又返回值 可以抛出异常")]),n._v(" "),e("li",[n._v("execute: 参数Runnable 没有返回值\n##47. 在 java 程序中怎么保证多线程的运行安全？")]),n._v(" "),e("li",[n._v("1.原子性：提供互斥访问，同一时刻只能有一个线程对数据惊醒操作 atomic synchronized")]),n._v(" "),e("li",[n._v("2.可见性：一个线程对主内存的修改可以及时的被其他线程看到 synchronized volatile")]),n._v(" "),e("li",[n._v("3.有序性：程序执行的顺序按照代码的先后顺序执行 heppends-before\n##48. 多线程锁的升级原理是什么？")]),n._v(" "),e("li",[n._v("无锁>偏向锁>轻量级锁>重量级锁  sychronized没优化之前重量级锁，线程切换很短暂，浪费资源")]),n._v(" "),e("li",[n._v("无锁：对资源不锁定，所有线程都能访问和修改，但同时只有一个能修改成功，其他的尝试不断修改")]),n._v(" "),e("li",[n._v("偏向锁：对象一直被同一个线程执行，不存在多竞争，该线程在后续执行中会自动获取🔐，降低获取所带来的开销，偏向，指的是偏向于第一个加锁的线程，该线程不会主动释放锁，只有当其他线程竞争时才会释放")]),n._v(" "),e("li",[n._v("轻量级锁：轻量级锁指的是偏向锁有第二个线程访问的时候就会升级为轻量级锁，线程B会通过自旋的方式来尝试获取锁，线程不会阻塞，从而提供性能，当自旋到达一定次数，或者有第三个线程来访问的时候升级为重量级锁")]),n._v(" "),e("li",[n._v("重量级锁：当一个线程获取锁之后，其他的线程处于阻塞状态。\n##49. 什么是死锁？\n互斥，请求与保持，不可剥夺，循环等待\n两个或以上的线程都占有对方需要的资源，僵住了\n##50. 怎么防止死锁")]),n._v(" "),e("li",[n._v("有序访问 破坏循坏等待")]),n._v(" "),e("li",[n._v("tryLock 尝试加锁 不可剥夺\n##51. ThreadLocal 是什么？有哪些使用场景？\n线程本地存储，每个线程都创建了ThreadLoalMap对象，每个线程可以访问ThreadLocalMap的值，不会冲突。\n方便同一线程使用某一对象，线程之间数据隔离，数据库连接，Session 日志ID\n##52. 说一下 synchronized 底层实现原理？\n没了解到\n##53. synchronized 和 volatile 的区别是什么？")]),n._v(" "),e("li",[n._v("volatile 只能作用于变量，只能保证可见性和有序性不能保证原子性，不会线程阻塞")]),n._v(" "),e("li",[n._v("synchronized 能作用域变量 ，方法，类，代码块。可见性，原子性，有序性都能保证，回阻塞\n##54. synchronized 和 Lock 有什么区别？\nSynchronized 属于JVM层面的锁，不需要用户手动释放。不可终端，除非异常\nLock属于API层面的锁，需要手动释放，lock，unLock ,try finally来完成，可中断，tryLock，interrupt,\nReentranLock 可以分组或者精确唤醒，\n##55. synchronized 和 ReentrantLock 区别是什么？")]),n._v(" "),e("li",[n._v("synchronized 非公平锁，等待不可中断，唤醒一个或一大堆")]),n._v(" "),e("li",[n._v("RenntranLock 可设置公平锁，可中断锁，可分组或精确唤醒\n##56. 说一下 atomic 的原理？\n使用无锁机制，只适用于计数器，累加器\n##57. 什么是反射？\n在运行时环境，对于任意一个类，能否知道这个类的属性和方法，对于一个对象，能否调用任意一个方法\n1.在运行是判断一个对象所属的类，2任意构造一个类的对象 3。判断一个类的方法和属性，4.调用对象的任意方法\n##58. 什么是 java 序列化？什么情况下需要序列化？\n-序列化指的是将对象转换成字节流的过程 ，反过来就是反过来\n-当java对象需要在网络上传输或者持久化存储的时候就需要序列化\n##59. 动态代理是什么？有哪些应用？\n当想给实现了某个类的接口的某个方法加一些额外的功能，比如日志记录等。可以给这个类一个代理，创建一个新类 拥有他的功能和加强的功能，动态生成的 aop\n##60. 怎么实现动态代理？\njdk 实现InvocationHandler实现Invoke方法,提供接口\nCGLIB 导入依赖，实现MethodInterceptor的Interceptor\n#对象拷贝\n##61. 为什么要使用克隆？\n对一个对象进行草最，又想保留原有的对象，克隆，分为深度克隆和浅克隆\n##62. 如何实现对象克隆？")]),n._v(" "),e("li",[n._v("浅复制：Object的Clone方法")]),n._v(" "),e("li",[n._v("深复制 序列化或者Json\n##63.深拷贝和浅拷贝区别是什么？\n深拷贝相当于两个对象，先拷贝是同一个引用\n#异常\n##74. throw 和 throws 的区别？")]),n._v(" "),e("li",[n._v("throw 表示方法内抛出某种异常对象，不是运行时异常则需要捕捉，try catch 捕捉，")]),n._v(" "),e("li",[n._v("throws 使用在方法的定义上，表示这个方法可能抛出异常，需要调用者处理\n##75.final、finally、finalize 有什么区别？\nfinalize　　Object的方法，被回收时调用，一般new出来的对象都能被回收，\n##76. try-catch-finally 中哪个部分可以省略？\ncatch 或 finally\n##77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\nreturn 前执行\n##78. 常见的异常类有哪些？\nTHrowable 根类\nIO 异常 DataFormar异常 sql 异常 运行时异常 ，空指针，内存溢出")])]),n._v(" "),e("p",[n._v("#设计模式")]),n._v(" "),e("h2",{attrs:{id:"说一下常用的设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下常用的设计模式"}},[n._v("#")]),n._v(" 说一下常用的设计模式")]),n._v(" "),e("ul",[e("li",[n._v("单例模式：一个类只有自己创建自己的一个实例，给其他所有的对象提供的都是这一个实例")]),n._v(" "),e("li",[n._v("工厂模式：创建一个对象的时候不用暴露创建逻辑，只需要通过一个共用的接口来指向新创建的对象")]),n._v(" "),e("li",[n._v("抽象工厂模式：围绕一个超级工厂创建其他工厂")]),n._v(" "),e("li",[n._v("适配器：将一个接口转换为另一个类希望的接口，解决接口不兼容的问题\n#Spring/Spring MVC\n##90. 为什么要使用 spring？")]),n._v(" "),e("li",[n._v("轻量，小，是非侵入式的，spring的对象不依赖于spring")]),n._v(" "),e("li",[n._v("控制反转，使用ioc促进低耦合，应用了ioc之后，一个对象所依赖的对象会通过被动的方式传递进来。而不是对象自己创建或查找依赖对象")]),n._v(" "),e("li",[n._v("面向切面编程 通过分离业务逻辑和系统级服务和事物进行内聚性开发。对象只关注完成业务逻辑，通过切面对一个对象的方法进行加强，完成一些系统级的服务，日志 事物")]),n._v(" "),e("li",[n._v('容器 spring管理引用对象的生命周期和配置，默认是单例 scope = "singleton" prototype,request session\n##93.spring 有哪些主要模块？\nSpring有七大功能模块，分别是Spring Core，AOP，ORM，DAO，MVC，WEB，Context。\n1，Spring Core\nCore模块是Spring的核心类库，Spring的所有功能都依赖于该类库，Core主要实现IOC功能，Sprign的所有功能都是借助IOC实现的。\n2，AOP\nAOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常用的拦截器，供用户自定义和配置。\n3，ORM\nSpring 的ORM模块提供对常用的ORM框架的管理和辅助支持，Spring支持常用的Hibernate，ibtas，jdao等框架的支持，Spring本身并不对ORM进行实现，仅对常见的ORM框架进行封装，并对其进行管理\n4，DAO模块\nSpring 提供对JDBC的支持，对JDBC进行封装，允许JDBC使用Spring资源，并能统一管理JDBC事物，并不对JDBC进行实现。（执行sql语句）\n5，WEB模块\nWEB模块提供对常见框架如Struts1，WEBWORK（Struts 2），JSF的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器。\n6，Context模块\nContext模块提供框架式的Bean访问方式，其他程序可以通过Context访问Spring的Bean资源，相当于资源注入。\n7，MVC模块\nWEB MVC模块为Spring提供了一套轻量级的MVC实现，在Spring的开发中，我们既可以用Struts也可以用Spring自己的MVC框架，相对于Struts，Spring自己的MVC框架更加简洁和方便。\n##94.spring 常用的注入方式有哪些？\n构造方法 setter注入 @autowrie\n##95. spring 中的 bean 是线程安全的吗？\nspring 容器本身并没有提供线程安全策略。因此可以说容器中的bean是不具备线程安全的，如果是基于作用域来看的话 单例模式  不安全 prototype 安全 不存在共享，单例bean是无状态的就是安全的。多余有状态的bean一般是通过ThreadLoad去解决的\n##96.spring 支持几种 bean 的作用域？\nsingleton prototype request session global session\n##97.spring 自动装配 bean 有哪些方式？\nno 显示装配\nbyName 通过名称\nbyType 类型\n构造函数\nautodetect\n##98. spring 事务实现方式有哪些？')]),n._v(" "),e("li",[n._v("编程式事物 beginTransaction commit rollback")]),n._v(" "),e("li",[n._v("基于TransactionProxyFactoryBean的声明式事物")]),n._v(" "),e("li",[n._v("@Transaction的声明式")]),n._v(" "),e("li",[n._v("基于Aspectj AOP配置事务\n##99. 说一下 spring 的事务隔离？\n读为提交 读已提交 可重复读 串行化\n##100.说一下 spring mvc 运行流程？\n我知道了\n##101.spring mvc 有哪些组件？\n前端控制器，处理器映射器，处理器适配器。拦截器，主题解析，视图解析，异常处理器，文件上传器\n##102.@RequestMapping 的作用是什么？\n用于类和方法上，用于路径匹配\n##103.@Autowired 的作用是什么？\n用于依赖注入\n#十一、Spring Boot/Spring Cloud\n##104.什么是 spring boot？\nspringBoot 是spring开源框架下面的一个子项目，是spring的一站式解决方案，主要是降低了spring的使用难度，降低了对配置的要求，简化了spring的配置文件，没有代码和XML的生成，内齿tomcat能够独立运行。\n##105.为什么要用 spring boot？\n使编码 配置，部署 监控更简单\n##106.spring boot 核心配置文件是什么？\nbootstrap 和application\n##107.spring boot 配置文件有哪几种类型？它们有什么区别？")]),n._v(" "),e("li",[n._v("yml: key：val 层次感更强  不支持注解导入配置")]),n._v(" "),e("li",[n._v("properties： 键值对 =\n##108.spring boot 有哪些方式可以实现热部署？\nSpring Loaded spring-boot-evtools\n##110.什么是 spring cloud？\n基于springboot的一套微服务治理方案，用于快速构建分布式系统\n##111.spring cloud 断路器的作用是什么？\n防止雪崩效应，当一个请求调用另一个请求时，由于网络或者自身的原因出现问题，就会出现长时间等待\n##112.spring cloud 的核心组件有哪些？\neurack 注册中心 hystrix 熔断器  ribbon 负载均衡 config 配置中心  zuul 路由")])]),n._v(" "),e("p",[n._v("#mysql\n##什么是事物,\n事物是一组具有原子性的sql语句，或者说是一个独立的工作单元\n##说一下 ACID 是什么？")]),n._v(" "),e("blockquote",[e("ul",[e("li",[n._v("ATOMICITY 原子性 一个事物必须被视为一个不可分可的最小工作单元，事物中的操作要么全部成功，要么全部失败")]),n._v(" "),e("li",[n._v("CONSISTENCY 一致性 指事物从一种一致性状态装换为另一种一致性状态，转账总余额不变,事物开始之前和之后数据库的数据的完整性没有被破坏")]),n._v(" "),e("li",[n._v("ISOLATION 隔离性 一个事物对数据库数据的操作，在未提交完成前，对于其他事物是不可见的")])]),n._v(" "),e("blockquote",[e("ul",[e("li",[n._v("未提交读 事物对数据的修改，即使没提交对其他事物也是可见的。这个读取操作叫做脏读，数据就叫脏数据")]),n._v(" "),e("li",[n._v("已提交读 一个事物开始到结束中间的修改对其他的事物是不可见的  解决脏读")]),n._v(" "),e("li",[n._v("可重复读 一个事物中对一个数据的多次读取结果是一致的")]),n._v(" "),e("li",[n._v("串行化 在读取的每一行数据上加锁")])])]),n._v(" "),e("ul",[e("li",[n._v("持久性，一旦提交，所做的修改即使系统崩溃也不会丢失")])])])])}),[],!1,null,null,null);i.default=t.exports}}]);